
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>gridObj</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-05-22"><meta name="DC.source" content="gridObj.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Properties that are computed as and when needed.</a></li><li><a href="#3">Indices of layers and confining bed in total layer stack</a></li><li><a href="#4">Size of grid</a></li><li><a href="#5">Coordinates</a></li><li><a href="#6">Distances and thicnesses</a></li><li><a href="#7">Volumes and aeas</a></li><li><a href="#8">distance to xm=0 (along the x-axis) for axi-symmetric situations</a></li><li><a href="#9">Axial flow</a></li><li><a href="#12">Convert the grid to reflect then new outcut defined by Ix,Iy</a></li><li><a href="#14">X coordinates</a></li><li><a href="#15">Z-coordinates</a></li><li><a href="#16">Boundary conditions input using point specifications</a></li><li><a href="#17">Boundary conditions input using polyline speicfication</a></li><li><a href="#18">Boundary condition input using 3D surfaces</a></li><li><a href="#19">Boundary conditions input using line specificaiton</a></li><li><a href="#21">take LAYCBD into account</a></li><li><a href="#23">gr.spyBCN(BN) -- spy's BCN where BCN is WEL, CHD, DRN etc</a></li></ul></div><pre class="codeinput"><span class="keyword">classdef</span> gridObj
    <span class="comment">%   gr = gridObj(xGr,yGr[,zGr [,LAYCBD[, MINDZ[, AXIAL]]])</span>
    <span class="comment">%   generates a grid object with properies and methods through which</span>
    <span class="comment">%   this object can provide any required information on the grid.</span>
    <span class="comment">%   Essential is the difference between layers (= model cell layers, all</span>
    <span class="comment">%   variables with lay, Lay or LAY in them) and confining beds (all</span>
    <span class="comment">%   variables with cbd, Cbd or CBD in them). Confining beds or CBD for</span>
    <span class="comment">%   short are not counted as layers. They are optionally intermediate</span>
    <span class="comment">%   between two layers and connected to the bottom of the layer with</span>
    <span class="comment">%   which they are associated. The actual configuration is given</span>
    <span class="comment">%   in vector LAYCBD(Nlay,1) in which a value &gt;0 indicates a model layer</span>
    <span class="comment">%   with a confining bed below it. Layers without a confining bed</span>
    <span class="comment">%   associated to them have LAYCBD=0. LAYCBD(end)=0 is guaranteed by mfLab.</span>
    <span class="comment">%   Z is the elvation of all tops and bottom of layers and confining beds</span>
    <span class="comment">%   combined and, therefore, its third dimension is subject to the</span>
    <span class="comment">%   condition:</span>
    <span class="comment">%        Nlay+1&lt;=size(Z,3)&lt;2NLay</span>
    <span class="comment">%   To avoid confusion, Z adn Nz are hidden. Use Nlay and Ncbd instead.</span>
    <span class="comment">%   use ZTlay and ZBlay, ZTcbd and ZBcbd to get the elevations of the</span>
    <span class="comment">%   tops and bottoms of the model layers and confining beds.</span>
    <span class="comment">%</span>
    <span class="comment">%   TO 110810; 120516</span>

    <span class="keyword">properties</span> (Constant) <span class="comment">% also physically stored</span>
        type=<span class="string">'gridObj'</span>;
    <span class="keyword">end</span>
    <span class="keyword">properties</span>
        <span class="comment">% Properties that are actually stored. Their direct setting is</span>
        <span class="comment">% discouraged as this may cause inconsistencies. Always use the</span>
        <span class="comment">% standard constructor call</span>
        <span class="comment">% gr = gridObj(xGr,yGr,zGr,[LAYCBD [,MINDZ [,AXIAL]]]);</span>
        MINDZ=0.001;             <span class="comment">% minimum layer thickness</span>
        AXIAL=0;                 <span class="comment">% ~=0 if axial symmetric flow</span>
        LAYCBD=0;                <span class="comment">% layer confining bed vector</span>
        isLay;                   <span class="comment">% vector Nlay+Ncbd long telling if layer is LAY or CBD</span>
        xGr; yGr,                <span class="comment">% grid line coordinates, vectors of size Nx+1, Ny+1, Nz+1</span>
        xw0=0; yw0=0; zw0=0; anglew=0;  <span class="comment">% position of model zero in real world coordinates</span>
        layersAreUniform,        <span class="comment">% true of all layers are uniform</span>
    <span class="keyword">end</span>
    <span class="keyword">properties</span> (Access=protected)
        <span class="comment">% Properties that are actually stored. Zgrfull or Zfull need not be</span>
        <span class="comment">% present. They are protected from being directly set as they are</span>
        <span class="comment">% computed carefully by the constructor.</span>
        zGrFull   <span class="comment">% original zGr array if full 3D and values for all corners</span>
        Zfull     <span class="comment">% original Z array of full 3D values for xm,ym and zGr</span>
    <span class="keyword">end</span>
    <span class="keyword">properties</span> (Dependent=true)
</pre><h2>Properties that are computed as and when needed.<a name="2"></a></h2><pre class="codeinput">        size, sizeLay, sizeCBD, sizeFULL, <span class="comment">% 3rd dimension size resepectively: Nlay Nlay Ncbd Nz</span>

        Nxy, Nxyz   <span class="comment">% Nx*Ny,   Nx*Ny*Nlay (total nr of model cells)</span>
</pre><h2>Indices of layers and confining bed in total layer stack<a name="3"></a></h2><pre class="codeinput">        ITlay,ITcbd,IBlay,IBcbd, <span class="comment">% pointer to top of layer  LAYTOP=Z(:,:,Itop)</span>
</pre><h2>Size of grid<a name="4"></a></h2><pre class="codeinput">        Nx, Ny, Nz,Nlay, Ncbd,    <span class="comment">% size of cells</span>
</pre><h2>Coordinates<a name="5"></a></h2><p>xm,xh=xc are cell centers. xh,xc same as xm with outer coordinates  replaced by xGr([1 end]) for contouring. xp is xGr(2:end-1) for  contouring stream function. Xm is full 2D cell center  coordinates. Same for y and z Variables that start with a capital letter are 3D arrays (except Xm and Ym which are 2D arrays) while varibles starting with a lower case letter are vectors.</p><pre class="codeinput">        xm, Xm, XM, XMlay, xh, xc, XC, xp, XP, XGR,
        ym, Ym, YM, YMlay, yh, yc, YC, yp, YP, YGR,

        zGr, ZGR, Z, zh, zc, ZC, zp, ZP, ZMlay, ZMcbd, ZM
        zlay, zLay, zTlay, zmlay, zMlay, zBlay,
        zcbd,       zTcbd, zmcbd, zMcbd, zBcbd,

        Zlay, ZGRlay, ZTlay, ZBlay, ZClay,
        Zcbd, ZGRcbd, ZTcbd, ZBcbd, ZCcbd,
</pre><h2>Distances and thicnesses<a name="6"></a></h2><pre class="codeinput">        dx,           DXlay, DXcbd, DX,
        dy,           DYlay, DYcbd, DY,
        dzlay, dzcbd, DZlay, DZcbd, DZ,
        dz, zm,
</pre><h2>Volumes and aeas<a name="7"></a></h2><pre class="codeinput">        Vlay, vlay             <span class="comment">% volume of model cells and of entire model</span>
        Vcbd, vcbd             <span class="comment">% volume of CBD per cell and total</span>
        AREA, area             <span class="comment">% surface area of model cells and entire model</span>
</pre><h2>distance to xm=0 (along the x-axis) for axi-symmetric situations<a name="8"></a></h2><pre class="codeinput">        r, rm, dr, R, RM,
</pre><h2>Axial flow<a name="9"></a></h2><pre class="codeinput">        TWOPIR,     <span class="comment">% 2*pi*(abs(XM)).^2, full size</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
    methods
</pre><pre class="codeinput">        <span class="keyword">function</span> o=gridObj(xGr,yGr,Z,LAYCBD,MINDZ,AXIAL)
            <span class="keyword">if</span> nargin==0; <span class="keyword">return</span>; <span class="keyword">end</span>
            <span class="keyword">if</span> nargin&lt;3,
                error(<span class="string">'not enough input arguments for gridObj: use gridObj(xGr,yGr,zGR[,LAYCBD[,MINDX[,AXIAL]]])'</span>);
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(xGr), display(xGr); error(<span class="string">'gridObj/gridObj call has empty first argument xGr, check it in mf_adapt.'</span>); <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(yGr), display(yGr); error(<span class="string">'gridObj/gridObj call has empty  2nd  argument yGr, check it in mf_adapt.'</span>); <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(Z)  , display(Z  ); error(<span class="string">'gridObj/gridObj call has empty  3rd  argument zGr, check it in mf_adapt.'</span>); <span class="keyword">end</span>

            <span class="keyword">if</span> nargin&gt;3, o.LAYCBD=LAYCBD; <span class="keyword">end</span>
            <span class="keyword">if</span> nargin&gt;4, o.MINDZ =MINDZ;  <span class="keyword">end</span>
            <span class="keyword">if</span> nargin&gt;5, o.AXIAL =AXIAL;  <span class="keyword">end</span>

            o.xGr = unique(xGr(:))';
            o.yGr = unique(yGr(:));   <span class="comment">% flipud is not really necessary</span>
            <span class="comment">%o.yGr=flipdim(unique(yGr(:)),1);</span>
            zisVector = sum([size(Z,1)==1,size(Z,2)==1,size(Z,3)==1])==2;

            <span class="keyword">if</span> zisVector,
                o.layersAreUniform=1;
                o.Zfull   = XS(flipdim(unique(Z(:)),1));
                o.zGrFull = XS(flipdim(unique(Z(:)),1));
            <span class="keyword">elseif</span> size(Z,3)==1, <span class="comment">% non vector Z must be 3D</span>
                    error(<span class="string">'gridObj:gridObj:Znot3D'</span>,<span class="keyword">...</span>
                        <span class="string">'3rd argument Z (or zGr) must be 3D unless it is given as a vector'</span>);
            <span class="keyword">else</span>
                o.zGrFull = mean(mean(Z,1),2);
                o.layersAreUniform = all(Z(1,1,:)==o.zGrFull);
                <span class="keyword">if</span> o.layersAreUniform
                    o.Zfull=o.zGrFull;
                <span class="keyword">else</span>
                    o.Zfull=Z;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">%1: guarantee size(..,i) is &gt;=2 in all three i directions</span>
            <span class="keyword">if</span> numel(o.xGr)==1 || ~isvector(o.xGr),
                error(<span class="string">'gridObj/gridObj: arg 1, xGr must be a vector with &gt;1 elements'</span>);
            <span class="keyword">end</span>
            <span class="keyword">if</span> numel(o.yGr)==1 || ~isvector(o.yGr),
                error(<span class="string">'gridObj/gridObj: arg 2, yGr, must be a vector with &gt;1 elmements.'</span>);
            <span class="keyword">end</span>
            <span class="keyword">if</span> numel(o.zGrFull)==1
                error(<span class="string">'gridObj/gridObj: arg 3, (zGr or Z), must have &gt;1 elements'</span>);
            <span class="keyword">end</span>

            <span class="comment">%3: make sure Z runs from high to low</span>
            <span class="comment">% find a point in the grid where Z are not NaN</span>
            Ntrials=10;
            I=find(~isnan(o.Z(:,:,1)),Ntrials,<span class="string">'first'</span>);
            <span class="keyword">for</span> itr=1:Ntrials
                <span class="keyword">if</span> ~isnan(o.Z(I(itr)+o.Ny*o.Nx*(size(o.Z,3)-1)))
                    <span class="keyword">break</span>;
                <span class="keyword">elseif</span> itr==Ntrials
                    error(<span class="string">'gridObj:gidObj:zBotNaN'</span>,<span class="keyword">...</span>
                        <span class="string">'In %d trials, I found no z columns with bottom values not NaN'</span>,Ntrials);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            RCL = cellIndices(I(itr),[o.Ny o.Nx 1],<span class="string">'RCL'</span>);
            <span class="keyword">if</span> o.Zfull(RCL(1),RCL(2),end)&gt;o.Zfull(RCL(1),RCL(2),1),
                o.Zfull=flipdim(o.Zfull,3);  <span class="comment">% flip o.Zfull so that it will run form high to low</span>
            <span class="keyword">end</span>;

            <span class="comment">%4: Guarantee minimum layer thickness</span>
            minLayerThickness=min(min(min(-diff(o.Zfull,1,3))));
            <span class="keyword">if</span> minLayerThickness&lt;o.MINDZ
                warning(<span class="string">'gridObj:gridObj:layerThicness'</span>,<span class="keyword">...</span>
                    [<span class="string">'gridObj/gridObj: min layer thickness = %g (&lt;%s),\n'</span>,<span class="keyword">...</span>
                     <span class="string">'correct this before restarting.'</span>],minLayerThickness,o.MINDZ);
            <span class="keyword">end</span>

            <span class="comment">%6: In case size(o.Zfull)=[Ny+1,Nx+1,Nz+1] make it [Ny,Nx,Nz]</span>
            <span class="keyword">if</span> ~o.layersAreUniform
                <span class="keyword">if</span> size(o.Zfull,1)&gt;o.Ny,  o.Zfull=0.5*(o.Zfull(1:end-1,:,:)+o.Zfull(2:end,:,:)); <span class="keyword">end</span>
                <span class="keyword">if</span> size(o.Zfull,2)&gt;o.Nx,  o.Zfull=0.5*(o.Zfull(:,1:end-1,:)+o.Zfull(:,2:end,:)); <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> o.AXIAL
                i=find(o.xGr&lt;0,1,<span class="string">'last'</span>);
                j=find(o.xGr&gt;0,1,<span class="string">'first'</span>);
                <span class="keyword">if</span> ~isempty(i) &amp;&amp; ~isempty(j) &amp;&amp; isempty(o.xGr==0) <span class="comment">% we must split xGr and o.Zfull</span>
                    o.xGr=[o.xGr(1:i  )         0            o.xGr(j:end)];
                    o.Zfull    =[o.Zfull(:,1:i,:) mean(o.Zfull(:,i:j,:),2) o.Zfull(:,j:end,:)];
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            [o.isLay,o.LAYCBD]=isLayer(o.Nz,o.LAYCBD);

        <span class="keyword">end</span>

        <span class="keyword">function</span> o = convert(o,Ix,Iy,LAYCBD)
</pre><h2>Convert the grid to reflect then new outcut defined by Ix,Iy<a name="12"></a></h2><pre>where Ix and Iy are the old indices.</pre><pre class="codeinput">            <span class="keyword">if</span> max(Ix)&gt;o.Nx || min(Ix)&lt;1,
                error(<span class="string">'gridObj/convert: Ix indices must be between 1 and %d.'</span>,o.Nx); <span class="keyword">end</span>
            <span class="keyword">if</span> max(Iy)&gt;o.Ny || min(Iy)&lt;1,
                error(<span class="string">'gridObj/convert: Iy indices must be between 1 and %d.'</span>,o.Ny); <span class="keyword">end</span>

            <span class="keyword">if</span> nargin&lt;4, LAYCBD=o.LAYCBD; <span class="keyword">end</span>

            <span class="keyword">if</span> length(LAYCBD)+sum(LAYCBD&gt;0)~=length(o.LAYCBD)+sum(o.LAYCBD&gt;0),
                error([<span class="string">'gridObj/convert: new and old LAYCBD have different total number of layers\n'</span>,<span class="keyword">...</span>
                     <span class="string">'namely new: Nlay=%d Ncbd=%d, versus old: Nlay=%d Ncbd=%d'</span>],<span class="keyword">...</span>
                     lenght(LAYCBD),sum(LAYCBD&gt;0),o.Nlay+o.Ncbd);
            <span class="keyword">end</span>

            o.Zfull  = o.Zfull(Iy,Ix,:);
            o.xGr = o.xGr([ Ix(1:end), Ix(end)+1 ]);
            o.yGr = o.yGr([ Iy(1:end); Iy(end)+1 ]);
            [o.isLay o.LAYCBD] = isAquifer(o.Nlay+o.Ncbd,LAYCBD);
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> AXIAL = get.AXIAL(o), AXIAL = o.AXIAL;  <span class="keyword">end</span>
        <span class="keyword">function</span> LAYCBD= get.LAYCBD(o), LAYCBD=o.LAYCBD; <span class="keyword">end</span>

        <span class="keyword">function</span> size    = get.size(o),    size    = [o.Ny, o.Nx, o.Nlay]; <span class="keyword">end</span>
        <span class="keyword">function</span> sizeLay = get.sizeLay(o), sizeLay = [o.Ny, o.Nx, o.Nlay]; <span class="keyword">end</span>
        <span class="keyword">function</span> sizeCBD = get.sizeCBD(o), sizeCBD = [o.Ny, o.Nx, o.Ncbd]; <span class="keyword">end</span>
        <span class="keyword">function</span> sizeFULL= get.sizeFULL(o), sizeFULL=[o.Ny, o.Nx, o.Nz  ]; <span class="keyword">end</span>

        <span class="keyword">function</span> Nxy  = get.Nxy(o),  Nxy = o.Nx*o.Ny;            <span class="keyword">end</span>
        <span class="keyword">function</span> Nxyz = get.Nxyz(o), Nxyz= o.Nx*o.Ny*o.Nlay;     <span class="keyword">end</span>
        <span class="keyword">function</span> Nx   = get.Nx(o) ,  Nx   = numel(o.xm);   <span class="keyword">end</span>
        <span class="keyword">function</span> Ny   = get.Ny(o) ,  Ny   = numel(o.ym);   <span class="keyword">end</span>
        <span class="keyword">function</span> Nz   = get.Nz(o) ,  Nz   = numel(o.zm);   <span class="keyword">end</span>
        <span class="keyword">function</span> Nlay = get.Nlay(o), Nlay = sum( o.isLay); <span class="keyword">end</span>
        <span class="keyword">function</span> Ncbd = get.Ncbd(o), Ncbd = sum(~o.isLay); <span class="keyword">end</span>
</pre><pre class="codeoutput">
ans = 

</pre><h2>X coordinates<a name="14"></a></h2><pre class="codeinput">        <span class="keyword">function</span> xGr   = get.xGr(o), xGr = o.xGr; <span class="keyword">end</span>
        <span class="keyword">function</span> xm    = get.xm(o)    , xm    = 0.5*(o.xGr(1:end-1)+o.xGr(2:end));  <span class="keyword">end</span>
        <span class="keyword">function</span> XGR  = get.XGR(o), o.warn(<span class="string">'XGR'</span>); XGR = repmat(o.xGr,[o.Ny+1,1,o.Nz+1]); <span class="keyword">end</span>
        <span class="keyword">function</span> XM   = get.XM(o), o.warn(<span class="string">'XM'</span>); XM = repmat(o.xm ,[o.Ny  ,1,o.Nz  ]); <span class="keyword">end</span>
        <span class="keyword">function</span> XMlay= get.XMlay(o),XMlay = o.XM(:,:,o.isLay); <span class="keyword">end</span>
        <span class="keyword">function</span> Xm   = get.Xm(o),   Xm    = repmat(o.xm ,[o.Ny,1]); <span class="keyword">end</span>
        <span class="keyword">function</span> XC   = get.XC(o)
            XC = o.Xm;
            <span class="keyword">if</span> o.Nx&gt;1,
                XC(:,  1,:)=o.xGr(  1);
                XC(:,end,:)=o.xGr(end);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
<span class="comment">%         function XP   = get.XP(o), XP = repmat(o.xGr(2:end-1),[o.Nz,1,o.Nz]); end</span>
<span class="comment">%             XP = o.Xm;</span>
<span class="comment">%             if o.Nx&gt;1,</span>
<span class="comment">%                 XP(:,  1,:)=o.xGr(  1);</span>
<span class="comment">%                 XP(:,end,:)=o.xGr(end);</span>
<span class="comment">%             end</span>
<span class="comment">%         end</span>


        <span class="keyword">function</span> yGr   = get.yGr(o), yGr = o.yGr; <span class="keyword">end</span>
        <span class="keyword">function</span> ym    = get.ym( o), ym  = 0.5*(o.yGr(1:end-1)+o.yGr(2:end));  <span class="keyword">end</span>

        <span class="keyword">function</span> YGR   = get.YGR(o), o.warn(<span class="string">'YGR'</span>); YGR = repmat(o.yGr,[1,o.Nx+1,o.Nz+1]); <span class="keyword">end</span>
        <span class="keyword">function</span> YM    = get.YM(o), o.warn(<span class="string">'YM'</span>); YM = repmat(o.ym, [1,o.Nx  ,o.Nz]); <span class="keyword">end</span>
        <span class="keyword">function</span> YMlay = get.YMlay(o),YMlay = o.YM(:,:,o.isLay); <span class="keyword">end</span>
        <span class="keyword">function</span> Ym    = get.Ym(o),   Ym    = repmat(o.ym,[1,o.Nx]);       <span class="keyword">end</span>
        <span class="keyword">function</span> YC    = get.YC(o)
            YC = o.Ym;
            <span class="keyword">if</span> o.Ny&gt;1
                YC(1,  :)=o.yGr(  1);
                YC(end,:)=o.yGr(end);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>Z-coordinates<a name="15"></a></h2><pre class="codeinput">        <span class="keyword">function</span> zGr   = get.zGr(o), zGr = o.zGrFull; <span class="keyword">end</span>
        <span class="keyword">function</span> zm    = get.zm(o)    , zm    = 0.5*(o.zGr(1:end-1)+o.zGr(2:end));  <span class="keyword">end</span>  <span class="comment">% center of model layers</span>

        <span class="keyword">function</span> zmlay = get.zmlay(o) , zmlay = o.zm( o.isLay);  <span class="keyword">end</span>  <span class="comment">% center of model layers</span>
        <span class="keyword">function</span> zmcbd = get.zmcbd(o) , zmcbd = o.zm(~o.isLay);  <span class="keyword">end</span>  <span class="comment">% center of model layers</span>

        <span class="keyword">function</span> zMlay = get.zMlay(o) , zMlay = o.zmlay;  <span class="keyword">end</span>  <span class="comment">% center of model layers</span>
        <span class="keyword">function</span> zMcbd = get.zMcbd(o) , zMcbd = o.zmcbd;  <span class="keyword">end</span>  <span class="comment">% center of model layers</span>

        <span class="keyword">function</span> zlay  = get.zlay(o),zlay= cat(3,o.zGr(o.isLay),o.zGr(end)); <span class="keyword">end</span>
        <span class="keyword">function</span> zLay  = get.zLay(o),zLay= o.zlay; <span class="keyword">end</span>
        <span class="keyword">function</span> zTlay = get.zTlay(o),zTlay = o.zGr(o.ITlay);   <span class="keyword">end</span>
        <span class="keyword">function</span> zBlay = get.zBlay(o),zBlay = o.zGr(o.ITlay+1); <span class="keyword">end</span>
        <span class="keyword">function</span> zTcbd = get.zTcbd(o),zTcbd = o.zGr(o.ITcbd);   <span class="keyword">end</span>
        <span class="keyword">function</span> zBcbd = get.zBcbd(o),zBcbd = o.zGr(o.ITcbd+1); <span class="keyword">end</span>

        <span class="keyword">function</span> ZGR = get.ZGR(o), o.warn(<span class="string">'ZGR'</span>); ZGR = o.Zfull;  <span class="keyword">end</span>
        <span class="keyword">function</span> Z   = get.Z(o),    o.warn(<span class="string">'Z'</span>);
            <span class="keyword">if</span> o.layersAreUniform, Z = repmat(o.zGr,[o.Ny,o.Nx]);
            <span class="keyword">else</span>                   Z = o.Zfull;          <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> ZM    = get.ZM(o), o.warn(<span class="string">'ZM'</span>); ZM  = 0.5*(o.Z(:,:,1:end-1)+o.Z(:,:,2:end)); <span class="keyword">end</span>
        <span class="keyword">function</span> ZC    = get.ZC(o), o.warn(<span class="string">'ZC'</span>);
            <span class="keyword">if</span> o.Nz&gt;1
                ZC  = o.ZM;
                ZC(:,:,[1 end])= o.Z(:,:,[1 end]);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> ZP    = get.ZP(o), o.warn(<span class="string">'ZP'</span>);  <span class="comment">% for plotting stream function (x-planes)</span>
            ZP  = 0.5*(o.Z(:,1:end-1,:)+o.Z(:,2:end,:));
        <span class="keyword">end</span>

        <span class="keyword">function</span> Zlay= get.Zlay(o),Zlay= cat(3,o.Z(:,:, o.isLay  ), o.Z(:,:,o.Nz+1)); <span class="keyword">end</span>
        <span class="keyword">function</span> ZTlay = get.ZTlay(o), ZTlay = o.Z( :,:,o.ITlay  ); <span class="keyword">end</span>
        <span class="keyword">function</span> ZMlay = get.ZMlay(o), ZMlay = o.ZM(:,:,o.isLay  ); <span class="keyword">end</span>  <span class="comment">% center Lay+CBD</span>
        <span class="keyword">function</span> ZBlay = get.ZBlay(o), ZBlay = o.Z( :,:,o.ITlay+1); <span class="keyword">end</span>
        <span class="keyword">function</span> ZClay = get.ZClay(o), ZClay = o.ZMlay;
            <span class="keyword">if</span> o.Nlay&gt;1
                ZClay(:,:,  1) = o.ZTlay(:,:,  1);
                ZClay(:,:,end) = o.ZBlay(:,:,end);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> Zcbd= get.Zcbd(o),Zcbd= cat(3,o.Z( :,:,~o.isLay  ), o.Z(:,:,o.Nz+1)); <span class="keyword">end</span>
        <span class="keyword">function</span> ZTcbd = get.ZTcbd(o), ZTcbd = o.Z( :,:, o.ITcbd  ); <span class="keyword">end</span>
        <span class="keyword">function</span> ZMcbd = get.ZMcbd(o), ZMcbd = o.ZM(:,:,~o.isLay  ); <span class="keyword">end</span>  <span class="comment">% center Lay+CBD</span>
        <span class="keyword">function</span> ZBcbd = get.ZBcbd(o), ZBcbd = o.Z( :,:, o.ITcbd+1); <span class="keyword">end</span>

        <span class="keyword">function</span> dx     = get.dx(o),    dx     =  abs(diff(o.xGr,1,2)); <span class="keyword">end</span>
        <span class="keyword">function</span> dy     = get.dy(o),    dy     =  abs(diff(o.yGr,1,1)); <span class="keyword">end</span>
        <span class="keyword">function</span> dz     = get.dz(o),    dz     =  abs(diff(o.zGr,1,3)); <span class="keyword">end</span>
        <span class="keyword">function</span> dzlay  = get.dzlay(o), dzlay  = o.dz(     o.isLay);    <span class="keyword">end</span>
        <span class="keyword">function</span> dzcbd  = get.dzcbd(o), dzcbd  = o.DZ(:,:,~o.isLay);    <span class="keyword">end</span>

        <span class="keyword">function</span> DX     = get.DX(o), o.warn(<span class="string">'DX'</span>);   DX     = repmat(o.dx ,[o.Ny,1,o.Nz]); <span class="keyword">end</span>
        <span class="keyword">function</span> DXlay  = get.DXlay(o), DXlay  = o.DX(:,:, o.isLay); <span class="keyword">end</span>
        <span class="keyword">function</span> DXcbd  = get.DXcbd(o), DXcbd  = o.DX(:,:,~o.isLay); <span class="keyword">end</span>
        <span class="keyword">function</span> DY     = get.DY(o), o.warn(<span class="string">'DY'</span>);   DY     = repmat(o.dy ,[1,o.Nx,o.Nz]); <span class="keyword">end</span>
        <span class="keyword">function</span> DYlay  = get.DYlay(o), DYlay  = o.DY(:,:, o.isLay); <span class="keyword">end</span>
        <span class="keyword">function</span> DYcbd  = get.DYcbd(o), DYcbd  = o.DY(:,:,~o.isLay); <span class="keyword">end</span>
        <span class="keyword">function</span> DZ     = get.DZ(o), o.warn(<span class="string">'DZ'</span>);
            <span class="keyword">if</span> isvector(o.Z)
                DZ = repmat(-diff(o.Z,1,3),[o.Ny,o.Nx,1]);
            <span class="keyword">else</span>
                DZ = abs(diff(-o.Z,1,3));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> DZlay  = get.DZlay(o), DZlay  = o.Z(:,:,o.ITlay)-o.Z(:,:,o.ITlay+1);  <span class="keyword">end</span>
        <span class="keyword">function</span> DZcbd  = get.DZcbd(o), DZcbd  = o.Z(:,:,o.ITcbd)-o.Z(:,:,o.ITcbd+1);  <span class="keyword">end</span>

        <span class="keyword">function</span> Vlay = get.Vlay(o),<span class="keyword">...</span>
                 Vlay = o.DX(:,:,o.isLay).* o.DY(:,:,o.isLay).* o.DZ(:,:,o.isLay);
        <span class="keyword">end</span>
        <span class="keyword">function</span> vlay = get.vlay(o), vlay = sum(o.Vlay(:));           <span class="keyword">end</span>
        <span class="keyword">function</span> Vcbd = get.Vcbd(o); Vcbd = o.DXcbd.* o.DYcbd.* o.DZcbd;  <span class="keyword">end</span>
        <span class="keyword">function</span> vcbd = get.vcbd(o); vcbd = sum(o.Vcbd(:));           <span class="keyword">end</span>

        <span class="keyword">function</span> AREA = get.AREA(o),  AREA = o.dy * o.dx;    <span class="keyword">end</span>
        <span class="keyword">function</span> area = get.area(o),  area = sum(sum(o.AREA)); <span class="keyword">end</span>

        <span class="comment">% axial symmetric, assuming r along x-axis using abs(x)</span>
        <span class="keyword">function</span> r  = get.r(o),  r  = sqrt(o.xGr.^2); <span class="keyword">end</span>
        <span class="keyword">function</span> rm = get.rm(o), rm = abs(o.xm);      <span class="keyword">end</span>
        <span class="keyword">function</span> dr = get.dr(o), dr = abs(o.dx);      <span class="keyword">end</span>
        <span class="keyword">function</span> R  = get.R( o), R  = sqrt(o.XGR.^2); <span class="keyword">end</span>
        <span class="keyword">function</span> RM = get.RM(o), RM = sqrt(o.XM.^2);  <span class="keyword">end</span>

        <span class="keyword">function</span> TWOPIR = get.TWOPIR(o), TWOPIR=2*pi*o.RM(:,:,o.isLay); <span class="keyword">end</span>

        <span class="comment">% world coordinates</span>
        <span class="keyword">function</span> xw0     = get.xw0(o), xw0=o.xw0; <span class="keyword">end</span>
        <span class="keyword">function</span> yw0     = get.yw0(o), yw0=o.yw0; <span class="keyword">end</span>
        <span class="keyword">function</span> zw0     = get.zw0(o), zw0=o.zw0; <span class="keyword">end</span>
        <span class="keyword">function</span> anglew  = get.anglew(o), anglew=o.anglew; <span class="keyword">end</span>

        <span class="comment">% facilitates plotting xh,yh,zh phased out use xc,yc,hc</span>
        <span class="keyword">function</span> xh  = get.xh(o) , xh  =  o.xc; <span class="keyword">end</span>  <span class="comment">% for heads</span>
        <span class="keyword">function</span> yh  = get.yh(o) , yh  =  o.yc; <span class="keyword">end</span>  <span class="comment">% for heads in xy plane</span>
        <span class="keyword">function</span> zh  = get.zh(o) , zh  =  o.zc; <span class="keyword">end</span>  <span class="comment">% for heads in zx plane</span>

        <span class="keyword">function</span> xc  = get.xc(o) , xc  = o.xm;  xc([1 end])=   o.xGr([1 end]);     <span class="keyword">end</span>  <span class="comment">% for concentrations</span>
        <span class="keyword">function</span> yc  = get.yc(o) , yc  = o.ym;  yc([1 end])=   o.yGr([1 end]);     <span class="keyword">end</span>  <span class="comment">% for concentrations</span>
        <span class="keyword">function</span> zc  = get.zc(o) , zc  = XS(o.zm); zc([1 end])=XS(o.zGr([1 end])); <span class="keyword">end</span>  <span class="comment">% for concentrations</span>

        <span class="comment">% coordinates to plot Psi (on all horizontal grid lines and</span>
        <span class="comment">% vertical gridline except the outer two</span>
        <span class="keyword">function</span> xp  = get.xp(o) , xp= o.xGr(2:end-1); <span class="keyword">end</span>  <span class="comment">% for Psi</span>
        <span class="keyword">function</span> yp  = get.yp(o) , yp= o.yGr;          <span class="keyword">end</span>  <span class="comment">% for Psi</span>
        <span class="keyword">function</span> zp  = get.zp(o) , zp= XS(o.zGr);      <span class="keyword">end</span>  <span class="comment">% for Psi</span>

        <span class="comment">% index in array Z which combines all interfaces</span>
        <span class="keyword">function</span> ITlay = get.ITlay(o), ITlay = find( o.isLay); <span class="keyword">end</span>
        <span class="keyword">function</span> IBlay = get.IBlay(o), IBlay = o.ITlay+1;      <span class="keyword">end</span>
        <span class="keyword">function</span> ITcbd = get.ITcbd(o), ITcbd = find(~o.isLay); <span class="keyword">end</span>
        <span class="keyword">function</span> IBcbd = get.IBcbd(o), IBcbd = o.ITcbd+1;      <span class="keyword">end</span>

        <span class="keyword">function</span> const = const(o,value)
            <span class="comment">% gridObj/const:  array = gr.const(value or vector)</span>
            <span class="comment">% if value is scalar:</span>
            <span class="comment">% generates a 3D array of size [gr.Ny,gr.Nx,gr.Nlay], with all values=value.</span>
            <span class="comment">% if value is vector,</span>
            <span class="comment">% generates a 3D array of size [gr.Ny,gr.Nx,length(value)], with</span>
            <span class="comment">% array(:,:,i)=value(i);</span>
            <span class="comment">%</span>
            <span class="comment">% TO 120410</span>
            <span class="keyword">if</span> isscalar(value)
                const=ones(o.Ny,o.Nx,o.Nlay)*value;
            <span class="keyword">else</span>
<span class="comment">%                 if numel(value)~=o.Nlay</span>
<span class="comment">%                     error('%s/array(..) requires one argument, a scalar or a vector length Nz\n',mfilename);</span>
<span class="comment">%                 end</span>
                const=repmat(XS(value(:)),[o.Ny,o.Nx,1]);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> dist = dist(o,x,y)
            <span class="comment">% gridObj/dist: dist=gr.dist(x,y)</span>
            <span class="comment">% yields the distance of all cell centers to point x,y</span>
            <span class="comment">%</span>
            <span class="comment">% TO 120410</span>

            <span class="keyword">switch</span> nargin
                 <span class="keyword">case</span> 1,
                     x=0; y=0;
                 <span class="keyword">case</span> 3,
                     <span class="keyword">if</span> ~isnumeric(x) || ~isnumeric(y)
                         error(<span class="string">'gridObj/dist: x and y must be scarlars.'</span>);
                     <span class="keyword">end</span>
                 <span class="keyword">otherwise</span>
                         error(<span class="string">'gridObj/dist: wrong number of argumens gridObj.dist() or gridObj.dis(x,y)'</span>);
            <span class="keyword">end</span>
            dist=sqrt((o.XMlay-x).^2+(o.YMlay-y).^2);
        <span class="keyword">end</span>
        <span class="keyword">function</span> o=setWorld(o,xw0,yw0,zw0,angle)
            <span class="comment">% gridObj/setWorld: obj=gr.setWorld(xw0,yw0,anglew)</span>
            <span class="comment">% sets world coordinate system for this grid. The</span>
            <span class="comment">% coordinates xw0,yw0 match model coordinates 0,0</span>
            <span class="comment">% angle is rotation of model relative to world, anticlockwise</span>
            <span class="comment">% from hoirzontal (east) as in mathematics.</span>
            <span class="comment">%</span>
            <span class="comment">% TO 120420</span>

            <span class="keyword">if</span> nargin&lt;3, error(<span class="string">'gridObj:setWorld:notEnoughInputArgs'</span>,<span class="keyword">...</span>
                    [<span class="string">'gridObj/setWorld: insuffcient input arguments, use\n'</span>,<span class="keyword">...</span>
                     <span class="string">'(xw,yw) or (xw,yw,anglew) or (xw,yw,zw,anglew).'</span>]);
            <span class="keyword">else</span>
                o.xw0=xw0;
                o.yw0=yw0;
                <span class="keyword">if</span> nargin==4
                    o.anglew=zw0;
                <span class="keyword">else</span>
                    o.zw0=zw0;
                    o.anglew=angle;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            o.anglew = o.anglew*pi/180; <span class="comment">% relative to east (x-axis)</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [xw yw]=world(o,xm,ym)
            <span class="comment">% gridObj/world:  [xw,yw]=gr.world(xm,ym)</span>
            <span class="comment">% computes xw yw in world coordinates, from model coordinates xm,ym</span>
            <span class="comment">% make sure you use consistent coordiates (feet, miles, km) in</span>
            <span class="comment">% both the world and model system.</span>
            <span class="comment">%</span>
            <span class="comment">% TO  1204020</span>
            <span class="keyword">try</span>
                p=all(size(xm)==size(ym));
            <span class="keyword">catch</span> ME
                error(<span class="string">'gridObj/world: size x arg must equal size y arg!'</span>);
            <span class="keyword">end</span>
            <span class="keyword">if</span> ~p, error(<span class="string">'gridObj/world: size x arg must equal size y arg!'</span>); <span class="keyword">end</span>

            xwyw=[xm(:),ym(:)] * [cos(o.anglew) sin(o.anglew); -sin(o.anglew) cos(o.anglew)];

            xw=reshape(xwyw(:,1),size(xm))+o.xw0;
            yw=reshape(xwyw(:,2),size(ym))+o.yw0;
        <span class="keyword">end</span>

        <span class="keyword">function</span> [xm ym]=model(o,xw,yw)
            <span class="comment">% [xm,ym]=gridObj/model(xw,yw) -- computes model coordinates form world</span>
            <span class="comment">% coordintes xw,yw</span>
            <span class="comment">% TO 120420</span>
            <span class="keyword">try</span>
                p=all(size(xw)==size(yw));
            <span class="keyword">catch</span> ME
                error(<span class="string">'gridObj/model: size xm (first arg) must equal size ym (2nd arg)!'</span>);
            <span class="keyword">end</span>
            <span class="keyword">if</span> ~p, error(<span class="string">'gridObj/model: size xm (first arg) must equal size ym (2nd arg)!'</span>); <span class="keyword">end</span>

            xmym = [xw(:)-o.xw0,yw(:)-o.yw0] * <span class="keyword">...</span>
                [cos(o.anglew) -sin(o.anglew); sin(o.anglew) cos(o.anglew)];

            xm=reshape(xmym,size(xw));
            ym=reshape(xmym,size(yw));
        <span class="keyword">end</span>
</pre><pre class="codeoutput">  gridObj

  Properties:
                type: 'gridObj'
               MINDZ: 1.0000e-03
               AXIAL: 0
              LAYCBD: 0
               isLay: []
                 xGr: []
                 yGr: []
                 xw0: 0
                 yw0: 0
                 zw0: 0
              anglew: 0
    layersAreUniform: []
                size: [0 0 0]
             sizeLay: [0 0 0]
             sizeCBD: [0 0 0]
            sizeFULL: [0 0 0]
                 Nxy: 0
                Nxyz: 0
               ITlay: []
               ITcbd: []
               IBlay: []
               IBcbd: []
                  Nx: 0
                  Ny: 0
                  Nz: 0
                Nlay: 0
                Ncbd: 0
                  xm: [1x0 double]
                  Xm: []
                  XM: []
               XMlay: []
                  XC: []
                  xp: [1x0 double]
                 XGR: []
                  ym: [1x0 double]
                  Ym: [1x0 double]
                  YM: [1x0x0 double]
               YMlay: [1x0x0 double]
                  YC: [1x0 double]
                  yp: []
                 YGR: []
                 zGr: []
                 ZGR: []
                   Z: []
                  zp: [1x0x0 double]
                  ZP: []
               ZMlay: []
               ZMcbd: []
                  ZM: []
               zTlay: []
               zmlay: []
               zMlay: []
               zBlay: []
               zTcbd: []
               zmcbd: []
               zMcbd: []
               zBcbd: []
                Zlay: []
               ZTlay: []
               ZBlay: []
               ZClay: []
                Zcbd: []
               ZTcbd: []
               ZBcbd: []
                  dx: []
               DXlay: []
               DXcbd: []
                  DX: []
                  dy: []
               DYlay: []
               DYcbd: []
                  DY: []
               dzlay: []
               dzcbd: []
               DZlay: []
               DZcbd: []
                  DZ: []
                  dz: []
                  zm: [1x0 double]
                Vlay: []
                vlay: 0
                Vcbd: []
                vcbd: 0
                AREA: []
                area: 0
                   r: []
                  rm: [1x0 double]
                  dr: []
                   R: []
                  RM: []
              TWOPIR: []


</pre><h2>Boundary conditions input using point specifications<a name="16"></a></h2><pre class="codeinput">        <span class="keyword">function</span> BCN=bcnPoint(o,basename,type,points,vals,Conc)
            <span class="comment">% gridObj/bcnPoint: BCN=gr.bcnPoint(basename,type,points,vals,conc)</span>
            <span class="comment">% Points is a list of world coordinates [x y] or [x y z] or {[x</span>
            <span class="comment">% y] iLay}. Vals is an [Npoly,n] array with one row per polyling.</span>
            <span class="comment">% and as manu values as neceesary, all of who will be appended</span>
            <span class="comment">% as extra columns to BCN putputhas. If Vals is a struct array</span>
            <span class="comment">% values may also be a string with the name of a header in</span>
            <span class="comment">% which will yield a single value for each stress period read from</span>
            <span class="comment">% the PER worksheet. Likewise for Conc, where Conc is [Npoly, NCOMP]</span>
            <span class="comment">% i.e. with one value for each concentration species involved</span>
            <span class="comment">%</span>
            <span class="comment">% TO 120410</span>

            BCN=<span class="string">'Stub: should become boundary condition input from points'</span>;
        <span class="keyword">end</span>
</pre><h2>Boundary conditions input using polyline speicfication<a name="17"></a></h2><pre class="codeinput">        <span class="keyword">function</span> BCN=bcnPoly(o,basename,type,poly,vals,conc)
            <span class="comment">% gridObj/bcnPoly: BCN=gr.bcnPoly(basename,type,poly,vals,conc)</span>
            <span class="comment">% same as bcnLine but now all points in the line are inlcuded</span>
            <span class="comment">% and vectors of data for a bcnPoly are not allowed, because</span>
            <span class="comment">% ambiguous. This may yield huge files, but also effective to</span>
            <span class="comment">% put any data into the mode that is available in polyline</span>
            <span class="comment">% shapes.</span>
            BCN=<span class="string">'Stub should become boundary condition input from polylines'</span>;
        <span class="keyword">end</span>
</pre><h2>Boundary condition input using 3D surfaces<a name="18"></a></h2><pre class="codeinput">        <span class="keyword">function</span> BCN=bcnSurf(o,basename,type,surf,vals,conc)
            <span class="comment">% gridObj/bcnSurf: BCN=gr.bncSurf(basename,surf,vals,conc)</span>
            <span class="comment">% not yet implemented</span>
            <span class="comment">% TODO:</span>
            BCN=<span class="string">'Stub: should become boundary condition input from surfaces'</span>;
        <span class="keyword">end</span>
</pre><h2>Boundary conditions input using line specificaiton<a name="19"></a></h2><pre class="codeinput">        <span class="keyword">function</span> BCN=bcnLine(o,basename,type,line,vals,conc)
</pre><pre class="codeinput">            <span class="comment">% gridObj/bcnLine: BCN=gr.bcnLine(basename,type,lline,vals,conc)</span>
            <span class="comment">% Generate input of boundary conditions given as lines.</span>
            <span class="comment">% eg  ...(basename,'WEL',lines,values,conc</span>
            <span class="comment">% lines may be a struct with lines x,y,z</span>
            <span class="comment">% values must have a value per line of a value for each point</span>
            <span class="comment">% of the line or a string with the header of a column in the</span>
            <span class="comment">% PER sheet to get values per stress perio. (one value for the</span>
            <span class="comment">% whole line for each stress period).</span>
            <span class="comment">% lines, as singe array [x y] or [x y z] or as {[x y] iLay}</span>
            <span class="comment">% vals as [val1 val1 val3 ...; next line; ...]</span>
            <span class="comment">% may also be a {val1 val2 val3 ...; netx line....}</span>
            <span class="comment">% where a val may be a scalar, a vector of length line or</span>
            <span class="comment">% a name of a header in the PER sheet in basename</span>
            <span class="comment">% coordinates. Facility to input lines and polylines</span>
            <span class="comment">% type one of {'WEL','DRN','RIV','GHB','CHD' 'DRT'}</span>
            <span class="comment">% not completely developed</span>
            <span class="comment">%</span>
            <span class="comment">% TO 120413</span>

            pline_xyz=line(:,1:3);

            P=linegrid(pline_xyz,o.xGr,o.yGr,o.zGr,o.LAYCBD);
</pre><h2>take LAYCBD into account<a name="21"></a></h2><pre class="codeinput">            <span class="keyword">for</span> i=1:length(P)
                P(i).iz =layer2aquif(P(i).iz,o.LAYCBD,o.Nz);
                P(i).Idx=(o.Ny*o.Nx)*(P(i).iz-1)+o.Ny*(P(i).ix-1)+P(i).iy;
            <span class="keyword">end</span>

            <span class="comment">% s along points</span>
            dS=sqrt(diff(line(:,1)).^2+diff(line(:,2)).^2+diff(line(:,3)).^2);
            S =[0 cumsum(dS)];

            <span class="comment">% s along the cell centers</span>
            ds=sqrt(diff([P.xm]).^2+diff([P.ym]).^2+diff([P.zm]).^2);
            s=[0 cumsum(ds)];

            iPer = 1; <span class="comment">% dummy stress period number</span>
            <span class="keyword">switch</span> lower(type)
                <span class="keyword">case</span> <span class="string">'drn'</span>
                    Hd  =interp1(S,line(:,3),s);
                    Lkn =interp1(S,line(:,4),s);
                    Lkn = Lkn.*[P.L];
                    BCN=[ones(size(P))' * iPer; [P.iz]; [P.iy]; [P.ix]; Hd; Lkn ]';
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> A=spyBCN(o,BCN)
</pre><h2>gr.spyBCN(BN) -- spy's BCN where BCN is WEL, CHD, DRN etc<a name="23"></a></h2><pre class="codeinput">            A=o.const(0);
            <span class="keyword">if</span> iscell(BCN)
                A(cellIndex(BCN{1}(:,[4,3,2]),o.size))=1;
            <span class="keyword">else</span>
                A(cellIndex(BCN(:,[4,3,2]),o.size))=1;
            <span class="keyword">end</span>
            figure; spy(XS(A));
</pre><pre class="codeinput">        <span class="keyword">end</span>
        <span class="comment">% Boundary condition input specification through zoneArray</span>
        <span class="keyword">function</span> [c,h]=streamlines(o,ax,Psi,prange,varargin)
            <span class="comment">% gr.streamlines(ax,Psi,crange,varargin)</span>
            <span class="comment">% plots streamline on ax given Psi, crange and the grid gr</span>
            <span class="comment">% TO 120517</span>
            PSI=NaN(o.Nlay+o.Ncbd+1,size(Psi,2));
            PSI( o.ITlay,:) = Psi(1:end-1,:);
            PSI( o.ITcbd,:) = Psi(find(o.LAYCBD)+1,:);
            PSI(  end   ,:) = Psi( end   ,:);

            [c,h]=contour(ax,ones(o.Nlay+o.Ncbd+1,1)*o.xp,XS(o.ZP),PSI,prange,varargin{:});
        <span class="keyword">end</span>
        <span class="keyword">function</span> streamlinesUpdate(o,h,Psi)
            <span class="comment">% gr.streamlinesUpdate(h,Psi) -- update streamlines associated</span>
            <span class="comment">% with handle h using Psi as new zdata</span>
            <span class="comment">% TO 120517</span>
            PSI=NaN(o.Nlay+o.Ncbd+1,size(Psi,2));
            PSI(o.ITlay,:) = Psi(1:end-1,:);
            PSI(o.ITcbd,:) = Psi(find(o.LAYCBD)+1,:);
            PSI( end   ,:) = Psi( end   ,:);
            set(h,<span class="string">'zdata'</span>,PSI);
        <span class="keyword">end</span>

        <span class="comment">% Boundary condition input specification through zoneArray</span>
        <span class="keyword">function</span> [c,h]=contour(o,ax,H,hrange,varargin)
            <span class="comment">% gr.contourf(ax,Psi,crange,varargin)</span>
            <span class="comment">% plots streamline on ax given Psi, crange and the grid gr</span>
            <span class="comment">% TO 120517</span>
           [c,h]=contour(ax,ones(o.Nz,1)*o.xc,XS(o.ZClay),H,hrange,varargin{:});
<span class="comment">%            [c,h]=contour(ax,o.xc,o.zc,H,hrange,varargin{:});</span>
        <span class="keyword">end</span>

        <span class="comment">% Boundary condition input specification through zoneArray</span>
        <span class="keyword">function</span> [c,h]=contourf(o,ax,H,hrange,varargin)
            <span class="comment">% gr.contourf(ax,Psi,crange,varargin)</span>
            <span class="comment">% plots streamline on ax given Psi, crange and the grid gr</span>
            <span class="comment">% TO 120517</span>
            [c,h]=contourf(ax,ones(o.Nz,1)*o.xc,XS(o.ZClay),H,hrange,varargin{:});
<span class="comment">%            [c,h]=contourf(ax,o.xc,o.zc,H,hrange,varargin{:});</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> plotgrid(o)
            <span class="comment">% gridObj/plotgrid: gr.plotgrid([clr[,well[,figname[,figcoords]]]])</span>
            <span class="comment">% plots the grid</span>
            <span class="comment">%</span>
            <span class="comment">% TO 120410</span>

            plotgrid(o.xGr,o.yGr);
        <span class="keyword">end</span>

        <span class="keyword">function</span> plot(o,alpha,gamma,cl,lw)  <span class="comment">% should become perspective view on model (not yet implemented)</span>
            <span class="comment">% gridObj/plot  gr.plot(alpha,gamma,cl,lw)</span>
            <span class="comment">% plots grid in 3D</span>
            <span class="comment">%</span>
            <span class="comment">% TOFIX:</span>
            <span class="comment">%</span>
            <span class="comment">% TO 120410</span>


            <span class="keyword">if</span> nargin&lt;5, lw=1; <span class="keyword">end</span>
            <span class="keyword">if</span> nargin&lt;4, cl=<span class="string">'k'</span>; <span class="keyword">end</span>

            eObs=[sin(alpha*pi/180),-cos(alpha*pi/180),cos(gamma*pi/180)];
            <span class="comment">% nomal vectoren e(x,y,z) to the 6 planes + plane index</span>
            e=[-1  0  0       1    1    1 o.Ny     1 o.Nz;
                1  0  0    o.Nx o.Nx    1 o.Ny     1 o.Nz;
                0 -1  0       1 o.Nx    1    1     1 o.Nz;
                0  1  0       1 o.Nx o.Ny o.Ny     1 o.Nz;
                0  0 -1       1 o.Nx    1 o.Ny  o.Nz o.Nz;
                0  0  1       1 o.Nx    1 o.Ny     1    1];

            <span class="keyword">for</span> i=1:size(e,1)
                <span class="keyword">if</span> cdot(e(1,1:3),eObs)&lt;0
                   surface(o.XGr(e(i,4:5),e(i,6:7),e(i,8:9)),<span class="keyword">...</span>
                           o.YGr(e(i,4:5),e(i,6:7),e(i,8:9)),<span class="keyword">...</span>
                           o.ZGr(e(i,4:5),e(i,6:7),e(i,8:9)),<span class="string">'color'</span>,cl,<span class="string">'linwidth'</span>,lw);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
    methods (Static)
            <span class="keyword">function</span> warn(Param)
            warning([<span class="string">'gridObj:'</span> Param <span class="string">':Use'</span> Param <span class="string">'lay'</span>],<span class="keyword">...</span>
                <span class="string">'gridObj/%s: LAYCBD~=0, use %slay instead of %s'</span>,Param,Param,Param);
            <span class="keyword">end</span>
    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
classdef gridObj
    %   gr = gridObj(xGr,yGr[,zGr [,LAYCBD[, MINDZ[, AXIAL]]])
    %   generates a grid object with properies and methods through which
    %   this object can provide any required information on the grid.
    %   Essential is the difference between layers (= model cell layers, all
    %   variables with lay, Lay or LAY in them) and confining beds (all
    %   variables with cbd, Cbd or CBD in them). Confining beds or CBD for
    %   short are not counted as layers. They are optionally intermediate
    %   between two layers and connected to the bottom of the layer with
    %   which they are associated. The actual configuration is given
    %   in vector LAYCBD(Nlay,1) in which a value >0 indicates a model layer
    %   with a confining bed below it. Layers without a confining bed
    %   associated to them have LAYCBD=0. LAYCBD(end)=0 is guaranteed by mfLab.
    %   Z is the elvation of all tops and bottom of layers and confining beds
    %   combined and, therefore, its third dimension is subject to the
    %   condition:
    %        Nlay+1<=size(Z,3)<2NLay
    %   To avoid confusion, Z adn Nz are hidden. Use Nlay and Ncbd instead.
    %   use ZTlay and ZBlay, ZTcbd and ZBcbd to get the elevations of the
    %   tops and bottoms of the model layers and confining beds.
    %
    %   TO 110810; 120516
    
    properties (Constant) % also physically stored
        type='gridObj';
    end
    properties
        % Properties that are actually stored. Their direct setting is
        % discouraged as this may cause inconsistencies. Always use the
        % standard constructor call
        % gr = gridObj(xGr,yGr,zGr,[LAYCBD [,MINDZ [,AXIAL]]]);
        MINDZ=0.001;             % minimum layer thickness
        AXIAL=0;                 % ~=0 if axial symmetric flow
        LAYCBD=0;                % layer confining bed vector
        isLay;                   % vector Nlay+Ncbd long telling if layer is LAY or CBD
        xGr; yGr,                % grid line coordinates, vectors of size Nx+1, Ny+1, Nz+1
        xw0=0; yw0=0; zw0=0; anglew=0;  % position of model zero in real world coordinates
        layersAreUniform,        % true of all layers are uniform
    end
    properties (Access=protected)
        % Properties that are actually stored. Zgrfull or Zfull need not be
        % present. They are protected from being directly set as they are
        % computed carefully by the constructor.
        zGrFull   % original zGr array if full 3D and values for all corners
        Zfull     % original Z array of full 3D values for xm,ym and zGr
    end
    properties (Dependent=true)
        %% Properties that are computed as and when needed.
        size, sizeLay, sizeCBD, sizeFULL, % 3rd dimension size resepectively: Nlay Nlay Ncbd Nz
        
        Nxy, Nxyz   % Nx*Ny,   Nx*Ny*Nlay (total nr of model cells)
        
        %% Indices of layers and confining bed in total layer stack
        ITlay,ITcbd,IBlay,IBcbd, % pointer to top of layer  LAYTOP=Z(:,:,Itop)
        
        %% Size of grid
        Nx, Ny, Nz,Nlay, Ncbd,    % size of cells
        
        %% Coordinates
        % xm,xh=xc are cell centers. xh,xc same as xm with outer coordinates
        %  replaced by xGr([1 end]) for contouring. xp is xGr(2:end-1) for
        %  contouring stream function. Xm is full 2D cell center
        %  coordinates. Same for y and z
        % Variables that start with a capital letter are 3D arrays (except
        % Xm and Ym which are 2D arrays) while varibles starting with a
        % lower case letter are vectors.
        xm, Xm, XM, XMlay, xh, xc, XC, xp, XP, XGR,
        ym, Ym, YM, YMlay, yh, yc, YC, yp, YP, YGR,          
        
        zGr, ZGR, Z, zh, zc, ZC, zp, ZP, ZMlay, ZMcbd, ZM
        zlay, zLay, zTlay, zmlay, zMlay, zBlay,
        zcbd,       zTcbd, zmcbd, zMcbd, zBcbd,
        
        Zlay, ZGRlay, ZTlay, ZBlay, ZClay,
        Zcbd, ZGRcbd, ZTcbd, ZBcbd, ZCcbd,
        
        %% Distances and thicnesses
        dx,           DXlay, DXcbd, DX,
        dy,           DYlay, DYcbd, DY,
        dzlay, dzcbd, DZlay, DZcbd, DZ,
        dz, zm,
        
        %% Volumes and aeas
        Vlay, vlay             % volume of model cells and of entire model
        Vcbd, vcbd             % volume of CBD per cell and total
        AREA, area             % surface area of model cells and entire model
        
        %% distance to xm=0 (along the x-axis) for axi-symmetric situations
        r, rm, dr, R, RM,
        
        %% Axial flow
        TWOPIR,     % 2*pi*(abs(XM)).^2, full size
end
    methods   
        function o=gridObj(xGr,yGr,Z,LAYCBD,MINDZ,AXIAL)
            if nargin==0; return; end
            if nargin<3,
                error('not enough input arguments for gridObj: use gridObj(xGr,yGr,zGR[,LAYCBD[,MINDX[,AXIAL]]])');
            end
            
            if isempty(xGr), display(xGr); error('gridObj/gridObj call has empty first argument xGr, check it in mf_adapt.'); end
            if isempty(yGr), display(yGr); error('gridObj/gridObj call has empty  2nd  argument yGr, check it in mf_adapt.'); end
            if isempty(Z)  , display(Z  ); error('gridObj/gridObj call has empty  3rd  argument zGr, check it in mf_adapt.'); end
            
            if nargin>3, o.LAYCBD=LAYCBD; end
            if nargin>4, o.MINDZ =MINDZ;  end
            if nargin>5, o.AXIAL =AXIAL;  end
            
            o.xGr = unique(xGr(:))';
            o.yGr = unique(yGr(:));   % flipud is not really necessary
            %o.yGr=flipdim(unique(yGr(:)),1);
            zisVector = sum([size(Z,1)==1,size(Z,2)==1,size(Z,3)==1])==2;
            
            if zisVector,
                o.layersAreUniform=1;
                o.Zfull   = XS(flipdim(unique(Z(:)),1));
                o.zGrFull = XS(flipdim(unique(Z(:)),1));
            elseif size(Z,3)==1, % non vector Z must be 3D
                    error('gridObj:gridObj:Znot3D',...
                        '3rd argument Z (or zGr) must be 3D unless it is given as a vector');
            else
                o.zGrFull = mean(mean(Z,1),2);
                o.layersAreUniform = all(Z(1,1,:)==o.zGrFull);
                if o.layersAreUniform
                    o.Zfull=o.zGrFull;
                else
                    o.Zfull=Z;
                end
            end

            %1: guarantee size(..,i) is >=2 in all three i directions
            if numel(o.xGr)==1 || ~isvector(o.xGr),
                error('gridObj/gridObj: arg 1, xGr must be a vector with >1 elements');
            end
            if numel(o.yGr)==1 || ~isvector(o.yGr),
                error('gridObj/gridObj: arg 2, yGr, must be a vector with >1 elmements.');
            end
            if numel(o.zGrFull)==1
                error('gridObj/gridObj: arg 3, (zGr or Z), must have >1 elements');
            end
            
            %3: make sure Z runs from high to low
            % find a point in the grid where Z are not NaN
            Ntrials=10;
            I=find(~isnan(o.Z(:,:,1)),Ntrials,'first');
            for itr=1:Ntrials
                if ~isnan(o.Z(I(itr)+o.Ny*o.Nx*(size(o.Z,3)-1)))
                    break;
                elseif itr==Ntrials
                    error('gridObj:gidObj:zBotNaN',...
                        'In %d trials, I found no z columns with bottom values not NaN',Ntrials);
                end
            end
            RCL = cellIndices(I(itr),[o.Ny o.Nx 1],'RCL');
            if o.Zfull(RCL(1),RCL(2),end)>o.Zfull(RCL(1),RCL(2),1),
                o.Zfull=flipdim(o.Zfull,3);  % flip o.Zfull so that it will run form high to low
            end;

            %4: Guarantee minimum layer thickness
            minLayerThickness=min(min(min(-diff(o.Zfull,1,3))));
            if minLayerThickness<o.MINDZ
                warning('gridObj:gridObj:layerThicness',...
                    ['gridObj/gridObj: min layer thickness = %g (<%s),\n',...
                     'correct this before restarting.'],minLayerThickness,o.MINDZ);
            end

            %6: In case size(o.Zfull)=[Ny+1,Nx+1,Nz+1] make it [Ny,Nx,Nz]
            if ~o.layersAreUniform
                if size(o.Zfull,1)>o.Ny,  o.Zfull=0.5*(o.Zfull(1:end-1,:,:)+o.Zfull(2:end,:,:)); end
                if size(o.Zfull,2)>o.Nx,  o.Zfull=0.5*(o.Zfull(:,1:end-1,:)+o.Zfull(:,2:end,:)); end
            end
            
            if o.AXIAL
                i=find(o.xGr<0,1,'last');
                j=find(o.xGr>0,1,'first');
                if ~isempty(i) && ~isempty(j) && isempty(o.xGr==0) % we must split xGr and o.Zfull                    
                    o.xGr=[o.xGr(1:i  )         0            o.xGr(j:end)];
                    o.Zfull    =[o.Zfull(:,1:i,:) mean(o.Zfull(:,i:j,:),2) o.Zfull(:,j:end,:)];
                end
            end
            
            [o.isLay,o.LAYCBD]=isLayer(o.Nz,o.LAYCBD);
                                    
        end
        
        function o = convert(o,Ix,Iy,LAYCBD)
            %% Convert the grid to reflect then new outcut defined by Ix,Iy
            %  where Ix and Iy are the old indices.
            if max(Ix)>o.Nx || min(Ix)<1,
                error('gridObj/convert: Ix indices must be between 1 and %d.',o.Nx); end
            if max(Iy)>o.Ny || min(Iy)<1,
                error('gridObj/convert: Iy indices must be between 1 and %d.',o.Ny); end
            
            if nargin<4, LAYCBD=o.LAYCBD; end
            
            if length(LAYCBD)+sum(LAYCBD>0)~=length(o.LAYCBD)+sum(o.LAYCBD>0),
                error(['gridObj/convert: new and old LAYCBD have different total number of layers\n',...
                     'namely new: Nlay=%d Ncbd=%d, versus old: Nlay=%d Ncbd=%d'],...
                     lenght(LAYCBD),sum(LAYCBD>0),o.Nlay+o.Ncbd);
            end
            
            o.Zfull  = o.Zfull(Iy,Ix,:);
            o.xGr = o.xGr([ Ix(1:end), Ix(end)+1 ]);
            o.yGr = o.yGr([ Iy(1:end); Iy(end)+1 ]);
            [o.isLay o.LAYCBD] = isAquifer(o.Nlay+o.Ncbd,LAYCBD);
        end
        
        function AXIAL = get.AXIAL(o), AXIAL = o.AXIAL;  end
        function LAYCBD= get.LAYCBD(o), LAYCBD=o.LAYCBD; end
        
        function size    = get.size(o),    size    = [o.Ny, o.Nx, o.Nlay]; end
        function sizeLay = get.sizeLay(o), sizeLay = [o.Ny, o.Nx, o.Nlay]; end
        function sizeCBD = get.sizeCBD(o), sizeCBD = [o.Ny, o.Nx, o.Ncbd]; end
        function sizeFULL= get.sizeFULL(o), sizeFULL=[o.Ny, o.Nx, o.Nz  ]; end
        
        function Nxy  = get.Nxy(o),  Nxy = o.Nx*o.Ny;            end
        function Nxyz = get.Nxyz(o), Nxyz= o.Nx*o.Ny*o.Nlay;     end
        function Nx   = get.Nx(o) ,  Nx   = numel(o.xm);   end
        function Ny   = get.Ny(o) ,  Ny   = numel(o.ym);   end
        function Nz   = get.Nz(o) ,  Nz   = numel(o.zm);   end
        function Nlay = get.Nlay(o), Nlay = sum( o.isLay); end
        function Ncbd = get.Ncbd(o), Ncbd = sum(~o.isLay); end
        
        %% X coordinates
        function xGr   = get.xGr(o), xGr = o.xGr; end
        function xm    = get.xm(o)    , xm    = 0.5*(o.xGr(1:end-1)+o.xGr(2:end));  end
        function XGR  = get.XGR(o), o.warn('XGR'); XGR = repmat(o.xGr,[o.Ny+1,1,o.Nz+1]); end
        function XM   = get.XM(o), o.warn('XM'); XM = repmat(o.xm ,[o.Ny  ,1,o.Nz  ]); end
        function XMlay= get.XMlay(o),XMlay = o.XM(:,:,o.isLay); end        
        function Xm   = get.Xm(o),   Xm    = repmat(o.xm ,[o.Ny,1]); end        
        function XC   = get.XC(o)
            XC = o.Xm;
            if o.Nx>1,
                XC(:,  1,:)=o.xGr(  1);
                XC(:,end,:)=o.xGr(end);
            end
        end
%         function XP   = get.XP(o), XP = repmat(o.xGr(2:end-1),[o.Nz,1,o.Nz]); end
%             XP = o.Xm;
%             if o.Nx>1,
%                 XP(:,  1,:)=o.xGr(  1);
%                 XP(:,end,:)=o.xGr(end);
%             end
%         end


        function yGr   = get.yGr(o), yGr = o.yGr; end
        function ym    = get.ym( o), ym  = 0.5*(o.yGr(1:end-1)+o.yGr(2:end));  end

        function YGR   = get.YGR(o), o.warn('YGR'); YGR = repmat(o.yGr,[1,o.Nx+1,o.Nz+1]); end
        function YM    = get.YM(o), o.warn('YM'); YM = repmat(o.ym, [1,o.Nx  ,o.Nz]); end
        function YMlay = get.YMlay(o),YMlay = o.YM(:,:,o.isLay); end        
        function Ym    = get.Ym(o),   Ym    = repmat(o.ym,[1,o.Nx]);       end
        function YC    = get.YC(o)
            YC = o.Ym;
            if o.Ny>1
                YC(1,  :)=o.yGr(  1);
                YC(end,:)=o.yGr(end);
            end
        end


        %% Z-coordinates
        function zGr   = get.zGr(o), zGr = o.zGrFull; end        
        function zm    = get.zm(o)    , zm    = 0.5*(o.zGr(1:end-1)+o.zGr(2:end));  end  % center of model layers
        
        function zmlay = get.zmlay(o) , zmlay = o.zm( o.isLay);  end  % center of model layers
        function zmcbd = get.zmcbd(o) , zmcbd = o.zm(~o.isLay);  end  % center of model layers        

        function zMlay = get.zMlay(o) , zMlay = o.zmlay;  end  % center of model layers
        function zMcbd = get.zMcbd(o) , zMcbd = o.zmcbd;  end  % center of model layers

        function zlay  = get.zlay(o),zlay= cat(3,o.zGr(o.isLay),o.zGr(end)); end
        function zLay  = get.zLay(o),zLay= o.zlay; end
        function zTlay = get.zTlay(o),zTlay = o.zGr(o.ITlay);   end
        function zBlay = get.zBlay(o),zBlay = o.zGr(o.ITlay+1); end
        function zTcbd = get.zTcbd(o),zTcbd = o.zGr(o.ITcbd);   end
        function zBcbd = get.zBcbd(o),zBcbd = o.zGr(o.ITcbd+1); end

        function ZGR = get.ZGR(o), o.warn('ZGR'); ZGR = o.Zfull;  end
        function Z   = get.Z(o),    o.warn('Z');
            if o.layersAreUniform, Z = repmat(o.zGr,[o.Ny,o.Nx]);
            else                   Z = o.Zfull;          end 
        end
        function ZM    = get.ZM(o), o.warn('ZM'); ZM  = 0.5*(o.Z(:,:,1:end-1)+o.Z(:,:,2:end)); end
        function ZC    = get.ZC(o), o.warn('ZC'); 
            if o.Nz>1
                ZC  = o.ZM;
                ZC(:,:,[1 end])= o.Z(:,:,[1 end]);
            end
        end
        function ZP    = get.ZP(o), o.warn('ZP');  % for plotting stream function (x-planes)
            ZP  = 0.5*(o.Z(:,1:end-1,:)+o.Z(:,2:end,:));
        end
        
        function Zlay= get.Zlay(o),Zlay= cat(3,o.Z(:,:, o.isLay  ), o.Z(:,:,o.Nz+1)); end
        function ZTlay = get.ZTlay(o), ZTlay = o.Z( :,:,o.ITlay  ); end 
        function ZMlay = get.ZMlay(o), ZMlay = o.ZM(:,:,o.isLay  ); end  % center Lay+CBD
        function ZBlay = get.ZBlay(o), ZBlay = o.Z( :,:,o.ITlay+1); end
        function ZClay = get.ZClay(o), ZClay = o.ZMlay;
            if o.Nlay>1
                ZClay(:,:,  1) = o.ZTlay(:,:,  1);
                ZClay(:,:,end) = o.ZBlay(:,:,end);
            end
        end

        function Zcbd= get.Zcbd(o),Zcbd= cat(3,o.Z( :,:,~o.isLay  ), o.Z(:,:,o.Nz+1)); end
        function ZTcbd = get.ZTcbd(o), ZTcbd = o.Z( :,:, o.ITcbd  ); end 
        function ZMcbd = get.ZMcbd(o), ZMcbd = o.ZM(:,:,~o.isLay  ); end  % center Lay+CBD
        function ZBcbd = get.ZBcbd(o), ZBcbd = o.Z( :,:, o.ITcbd+1); end 
   
        function dx     = get.dx(o),    dx     =  abs(diff(o.xGr,1,2)); end
        function dy     = get.dy(o),    dy     =  abs(diff(o.yGr,1,1)); end
        function dz     = get.dz(o),    dz     =  abs(diff(o.zGr,1,3)); end
        function dzlay  = get.dzlay(o), dzlay  = o.dz(     o.isLay);    end
        function dzcbd  = get.dzcbd(o), dzcbd  = o.DZ(:,:,~o.isLay);    end

        function DX     = get.DX(o), o.warn('DX');   DX     = repmat(o.dx ,[o.Ny,1,o.Nz]); end
        function DXlay  = get.DXlay(o), DXlay  = o.DX(:,:, o.isLay); end
        function DXcbd  = get.DXcbd(o), DXcbd  = o.DX(:,:,~o.isLay); end
        function DY     = get.DY(o), o.warn('DY');   DY     = repmat(o.dy ,[1,o.Nx,o.Nz]); end
        function DYlay  = get.DYlay(o), DYlay  = o.DY(:,:, o.isLay); end
        function DYcbd  = get.DYcbd(o), DYcbd  = o.DY(:,:,~o.isLay); end
        function DZ     = get.DZ(o), o.warn('DZ');
            if isvector(o.Z)
                DZ = repmat(-diff(o.Z,1,3),[o.Ny,o.Nx,1]);
            else
                DZ = abs(diff(-o.Z,1,3));
            end
        end
        function DZlay  = get.DZlay(o), DZlay  = o.Z(:,:,o.ITlay)-o.Z(:,:,o.ITlay+1);  end
        function DZcbd  = get.DZcbd(o), DZcbd  = o.Z(:,:,o.ITcbd)-o.Z(:,:,o.ITcbd+1);  end
        
        function Vlay = get.Vlay(o),...
                 Vlay = o.DX(:,:,o.isLay).* o.DY(:,:,o.isLay).* o.DZ(:,:,o.isLay);
        end
        function vlay = get.vlay(o), vlay = sum(o.Vlay(:));           end
        function Vcbd = get.Vcbd(o); Vcbd = o.DXcbd.* o.DYcbd.* o.DZcbd;  end
        function vcbd = get.vcbd(o); vcbd = sum(o.Vcbd(:));           end
        
        function AREA = get.AREA(o),  AREA = o.dy * o.dx;    end
        function area = get.area(o),  area = sum(sum(o.AREA)); end
        
        % axial symmetric, assuming r along x-axis using abs(x)
        function r  = get.r(o),  r  = sqrt(o.xGr.^2); end
        function rm = get.rm(o), rm = abs(o.xm);      end
        function dr = get.dr(o), dr = abs(o.dx);      end
        function R  = get.R( o), R  = sqrt(o.XGR.^2); end
        function RM = get.RM(o), RM = sqrt(o.XM.^2);  end
 
        function TWOPIR = get.TWOPIR(o), TWOPIR=2*pi*o.RM(:,:,o.isLay); end
        
        % world coordinates
        function xw0     = get.xw0(o), xw0=o.xw0; end
        function yw0     = get.yw0(o), yw0=o.yw0; end
        function zw0     = get.zw0(o), zw0=o.zw0; end
        function anglew  = get.anglew(o), anglew=o.anglew; end
        
        % facilitates plotting xh,yh,zh phased out use xc,yc,hc
        function xh  = get.xh(o) , xh  =  o.xc; end  % for heads
        function yh  = get.yh(o) , yh  =  o.yc; end  % for heads in xy plane
        function zh  = get.zh(o) , zh  =  o.zc; end  % for heads in zx plane

        function xc  = get.xc(o) , xc  = o.xm;  xc([1 end])=   o.xGr([1 end]);     end  % for concentrations  
        function yc  = get.yc(o) , yc  = o.ym;  yc([1 end])=   o.yGr([1 end]);     end  % for concentrations  
        function zc  = get.zc(o) , zc  = XS(o.zm); zc([1 end])=XS(o.zGr([1 end])); end  % for concentrations
        
        % coordinates to plot Psi (on all horizontal grid lines and
        % vertical gridline except the outer two
        function xp  = get.xp(o) , xp= o.xGr(2:end-1); end  % for Psi
        function yp  = get.yp(o) , yp= o.yGr;          end  % for Psi
        function zp  = get.zp(o) , zp= XS(o.zGr);      end  % for Psi
        
        % index in array Z which combines all interfaces
        function ITlay = get.ITlay(o), ITlay = find( o.isLay); end
        function IBlay = get.IBlay(o), IBlay = o.ITlay+1;      end
        function ITcbd = get.ITcbd(o), ITcbd = find(~o.isLay); end
        function IBcbd = get.IBcbd(o), IBcbd = o.ITcbd+1;      end

        function const = const(o,value)
            % gridObj/const:  array = gr.const(value or vector)
            % if value is scalar:
            % generates a 3D array of size [gr.Ny,gr.Nx,gr.Nlay], with all values=value.
            % if value is vector,
            % generates a 3D array of size [gr.Ny,gr.Nx,length(value)], with
            % array(:,:,i)=value(i);
            %
            % TO 120410
            if isscalar(value)
                const=ones(o.Ny,o.Nx,o.Nlay)*value;
            else
%                 if numel(value)~=o.Nlay
%                     error('%s/array(..) requires one argument, a scalar or a vector length Nz\n',mfilename);
%                 end
                const=repmat(XS(value(:)),[o.Ny,o.Nx,1]);
            end
        end
        function dist = dist(o,x,y)
            % gridObj/dist: dist=gr.dist(x,y)
            % yields the distance of all cell centers to point x,y
            %
            % TO 120410
            
            switch nargin
                 case 1,
                     x=0; y=0;
                 case 3,
                     if ~isnumeric(x) || ~isnumeric(y)
                         error('gridObj/dist: x and y must be scarlars.');
                     end
                 otherwise
                         error('gridObj/dist: wrong number of argumens gridObj.dist() or gridObj.dis(x,y)');
            end
            dist=sqrt((o.XMlay-x).^2+(o.YMlay-y).^2);
        end
        function o=setWorld(o,xw0,yw0,zw0,angle)
            % gridObj/setWorld: obj=gr.setWorld(xw0,yw0,anglew)
            % sets world coordinate system for this grid. The
            % coordinates xw0,yw0 match model coordinates 0,0
            % angle is rotation of model relative to world, anticlockwise
            % from hoirzontal (east) as in mathematics.
            %
            % TO 120420
            
            if nargin<3, error('gridObj:setWorld:notEnoughInputArgs',...
                    ['gridObj/setWorld: insuffcient input arguments, use\n',...
                     '(xw,yw) or (xw,yw,anglew) or (xw,yw,zw,anglew).']);
            else
                o.xw0=xw0;
                o.yw0=yw0;
                if nargin==4
                    o.anglew=zw0;
                else
                    o.zw0=zw0;
                    o.anglew=angle;
                end
            end
            o.anglew = o.anglew*pi/180; % relative to east (x-axis)
        end
        
        function [xw yw]=world(o,xm,ym)
            % gridObj/world:  [xw,yw]=gr.world(xm,ym)
            % computes xw yw in world coordinates, from model coordinates xm,ym
            % make sure you use consistent coordiates (feet, miles, km) in
            % both the world and model system.
            %
            % TO  1204020
            try
                p=all(size(xm)==size(ym));
            catch ME
                error('gridObj/world: size x arg must equal size y arg!');
            end
            if ~p, error('gridObj/world: size x arg must equal size y arg!'); end
                
            xwyw=[xm(:),ym(:)] * [cos(o.anglew) sin(o.anglew); -sin(o.anglew) cos(o.anglew)];

            xw=reshape(xwyw(:,1),size(xm))+o.xw0;
            yw=reshape(xwyw(:,2),size(ym))+o.yw0;
        end
        
        function [xm ym]=model(o,xw,yw)
            % [xm,ym]=gridObj/model(xw,yw) REPLACE_WITH_DASH_DASH computes model coordinates form world
            % coordintes xw,yw
            % TO 120420
            try
                p=all(size(xw)==size(yw));
            catch ME
                error('gridObj/model: size xm (first arg) must equal size ym (2nd arg)!');
            end
            if ~p, error('gridObj/model: size xm (first arg) must equal size ym (2nd arg)!'); end
            
            xmym = [xw(:)-o.xw0,yw(:)-o.yw0] * ...
                [cos(o.anglew) -sin(o.anglew); sin(o.anglew) cos(o.anglew)];
            
            xm=reshape(xmym,size(xw));
            ym=reshape(xmym,size(yw));
        end
                
        %% Boundary conditions input using point specifications
        
        function BCN=bcnPoint(o,basename,type,points,vals,Conc)
            % gridObj/bcnPoint: BCN=gr.bcnPoint(basename,type,points,vals,conc)
            % Points is a list of world coordinates [x y] or [x y z] or {[x
            % y] iLay}. Vals is an [Npoly,n] array with one row per polyling.
            % and as manu values as neceesary, all of who will be appended
            % as extra columns to BCN putputhas. If Vals is a struct array
            % values may also be a string with the name of a header in
            % which will yield a single value for each stress period read from
            % the PER worksheet. Likewise for Conc, where Conc is [Npoly, NCOMP]
            % i.e. with one value for each concentration species involved 
            %
            % TO 120410
            
            BCN='Stub: should become boundary condition input from points';
        end
        
        %% Boundary conditions input using polyline speicfication
        function BCN=bcnPoly(o,basename,type,poly,vals,conc)
            % gridObj/bcnPoly: BCN=gr.bcnPoly(basename,type,poly,vals,conc)
            % same as bcnLine but now all points in the line are inlcuded
            % and vectors of data for a bcnPoly are not allowed, because
            % ambiguous. This may yield huge files, but also effective to
            % put any data into the mode that is available in polyline
            % shapes.
            BCN='Stub should become boundary condition input from polylines';
        end
        
        %% Boundary condition input using 3D surfaces
        function BCN=bcnSurf(o,basename,type,surf,vals,conc)
            % gridObj/bcnSurf: BCN=gr.bncSurf(basename,surf,vals,conc)
            % not yet implemented
            % TODO:
            BCN='Stub: should become boundary condition input from surfaces';
        end
        
        %% Boundary conditions input using line specificaiton
        function BCN=bcnLine(o,basename,type,line,vals,conc)
            % gridObj/bcnLine: BCN=gr.bcnLine(basename,type,lline,vals,conc)
            % Generate input of boundary conditions given as lines.
            % eg  ...(basename,'WEL',lines,values,conc
            % lines may be a struct with lines x,y,z
            % values must have a value per line of a value for each point
            % of the line or a string with the header of a column in the
            % PER sheet to get values per stress perio. (one value for the
            % whole line for each stress period).
            % lines, as singe array [x y] or [x y z] or as {[x y] iLay}
            % vals as [val1 val1 val3 ...; next line; ...]
            % may also be a {val1 val2 val3 ...; netx line....} 
            % where a val may be a scalar, a vector of length line or
            % a name of a header in the PER sheet in basename
            % coordinates. Facility to input lines and polylines
            % type one of {'WEL','DRN','RIV','GHB','CHD' 'DRT'}
            % not completely developed
            %
            % TO 120413
            
            pline_xyz=line(:,1:3);
            
            P=linegrid(pline_xyz,o.xGr,o.yGr,o.zGr,o.LAYCBD); 
                        
            %% take LAYCBD into account
            for i=1:length(P)
                P(i).iz =layer2aquif(P(i).iz,o.LAYCBD,o.Nz);
                P(i).Idx=(o.Ny*o.Nx)*(P(i).iz-1)+o.Ny*(P(i).ix-1)+P(i).iy;
            end
            
            % s along points
            dS=sqrt(diff(line(:,1)).^2+diff(line(:,2)).^2+diff(line(:,3)).^2);
            S =[0 cumsum(dS)];
            
            % s along the cell centers
            ds=sqrt(diff([P.xm]).^2+diff([P.ym]).^2+diff([P.zm]).^2);
            s=[0 cumsum(ds)];
            
            iPer = 1; % dummy stress period number
            switch lower(type)
                case 'drn'
                    Hd  =interp1(S,line(:,3),s);
                    Lkn =interp1(S,line(:,4),s);
                    Lkn = Lkn.*[P.L];
                    BCN=[ones(size(P))' * iPer; [P.iz]; [P.iy]; [P.ix]; Hd; Lkn ]';
            end

        end
        
        function A=spyBCN(o,BCN)
            %% gr.spyBCN(BN) REPLACE_WITH_DASH_DASH spy's BCN where BCN is WEL, CHD, DRN etc
            A=o.const(0);
            if iscell(BCN)
                A(cellIndex(BCN{1}(:,[4,3,2]),o.size))=1;
            else
                A(cellIndex(BCN(:,[4,3,2]),o.size))=1;
            end
            figure; spy(XS(A));
        end
        % Boundary condition input specification through zoneArray
        function [c,h]=streamlines(o,ax,Psi,prange,varargin)
            % gr.streamlines(ax,Psi,crange,varargin)
            % plots streamline on ax given Psi, crange and the grid gr
            % TO 120517                        
            PSI=NaN(o.Nlay+o.Ncbd+1,size(Psi,2));
            PSI( o.ITlay,:) = Psi(1:end-1,:);
            PSI( o.ITcbd,:) = Psi(find(o.LAYCBD)+1,:);
            PSI(  end   ,:) = Psi( end   ,:);
            
            [c,h]=contour(ax,ones(o.Nlay+o.Ncbd+1,1)*o.xp,XS(o.ZP),PSI,prange,varargin{:});
        end
        function streamlinesUpdate(o,h,Psi)
            % gr.streamlinesUpdate(h,Psi) REPLACE_WITH_DASH_DASH update streamlines associated
            % with handle h using Psi as new zdata
            % TO 120517
            PSI=NaN(o.Nlay+o.Ncbd+1,size(Psi,2));
            PSI(o.ITlay,:) = Psi(1:end-1,:);
            PSI(o.ITcbd,:) = Psi(find(o.LAYCBD)+1,:);
            PSI( end   ,:) = Psi( end   ,:);
            set(h,'zdata',PSI);
        end
        
        % Boundary condition input specification through zoneArray
        function [c,h]=contour(o,ax,H,hrange,varargin)
            % gr.contourf(ax,Psi,crange,varargin)
            % plots streamline on ax given Psi, crange and the grid gr
            % TO 120517
           [c,h]=contour(ax,ones(o.Nz,1)*o.xc,XS(o.ZClay),H,hrange,varargin{:});
%            [c,h]=contour(ax,o.xc,o.zc,H,hrange,varargin{:});
        end

        % Boundary condition input specification through zoneArray
        function [c,h]=contourf(o,ax,H,hrange,varargin)
            % gr.contourf(ax,Psi,crange,varargin)
            % plots streamline on ax given Psi, crange and the grid gr
            % TO 120517
            [c,h]=contourf(ax,ones(o.Nz,1)*o.xc,XS(o.ZClay),H,hrange,varargin{:});
%            [c,h]=contourf(ax,o.xc,o.zc,H,hrange,varargin{:});
        end
        
        function plotgrid(o)
            % gridObj/plotgrid: gr.plotgrid([clr[,well[,figname[,figcoords]]]])
            % plots the grid
            %
            % TO 120410
            
            plotgrid(o.xGr,o.yGr);
        end
        
        function plot(o,alpha,gamma,cl,lw)  % should become perspective view on model (not yet implemented)
            % gridObj/plot  gr.plot(alpha,gamma,cl,lw)
            % plots grid in 3D
            %
            % TOFIX:
            %
            % TO 120410

            
            if nargin<5, lw=1; end
            if nargin<4, cl='k'; end
                        
            eObs=[sin(alpha*pi/180),-cos(alpha*pi/180),cos(gamma*pi/180)];
            % nomal vectoren e(x,y,z) to the 6 planes + plane index
            e=[-1  0  0       1    1    1 o.Ny     1 o.Nz;
                1  0  0    o.Nx o.Nx    1 o.Ny     1 o.Nz;
                0 -1  0       1 o.Nx    1    1     1 o.Nz;
                0  1  0       1 o.Nx o.Ny o.Ny     1 o.Nz;
                0  0 -1       1 o.Nx    1 o.Ny  o.Nz o.Nz;
                0  0  1       1 o.Nx    1 o.Ny     1    1];
               
            for i=1:size(e,1)
                if cdot(e(1,1:3),eObs)<0
                   surface(o.XGr(e(i,4:5),e(i,6:7),e(i,8:9)),...
                           o.YGr(e(i,4:5),e(i,6:7),e(i,8:9)),...
                           o.ZGr(e(i,4:5),e(i,6:7),e(i,8:9)),'color',cl,'linwidth',lw);
                end
            end
        end

    end
    methods (Static)
            function warn(Param)
            warning(['gridObj:' Param ':Use' Param 'lay'],...
                'gridObj/%s: LAYCBD~=0, use %slay instead of %s',Param,Param,Param);
            end
    end

end


##### SOURCE END #####
--></body></html>